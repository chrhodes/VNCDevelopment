<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//'------------------------------------------------------------------------------------------------------------------------
//'
//' TODO: Determine how to use the TraceEventType enumeration.  Vista seems to have more levels.  Windows 2003 fewer.  
//'       Should probably plan for future. Review the mapping levels
//'       Not sure how to get Critical messages to appear in eventlog.  Go look in EntLib code to see if they do mapping.
//'
//'       TraceEventType  Description                         Value   Vista Log   2003 Log    2008 Log    Log Method	    Priority Filter
//'       --------------  ---------------------------------   -----   ---------   --------    --------    ------------		---------------
//'       Critical        Fatal error or application crash    1       Error       ?           ?           Failure			Log.Failure		(-10)
//'       Error           Recoverable error                   2       Error                               Error				Log.Error		(-1)
//'       Warning         Non-Critical Problem                4       Warning                             Warning			Log.Warning		(1)       
//'       Information     Informational message               8       Information Information ?           Info				Log.Info		(100)
<#
	int infoLevels = 5;
	int debugLevels = 5;
    int archLevels = 40;
	int traceLevels = 30;

	for (int i = 1 ; i < infoLevels ; i++)
	{
#>
//'																										  Info<#= i #>				Log.Info<#= i #>		(10<#= i #>)
<#
	}
#>
//'       Verbose         Debugging trace                     16                                          Debug				Log.Debug		(1000)
<#
	for (int i = 1 ; i < debugLevels ; i++)
	{
#>
//'																										  Debug<#= i #>			Log.Debug<#= i #>		(100<#= i #>)
<#
	}
#>
//'                                                                                                       Arch              Log.Arch        (9000)
<#
	for (int i = 1 ; i < archLevels ; i++)
	{
#>
//'                                                                                                       Arch<#= i #>             Log.Arch<#= i #>       (900<#= i #>)
<#
	}
#>
//'                                                                                                       Trace             Log.Trace       (10000)
<#
	for (int i = 1 ; i < traceLevels ; i++)
	{
#>
//'                                                                                                       Trace<#= i #>			Log.Trace<#= i #>		(1000<#= i #>)
<#
	}
#>
//'
//'       Start          Starting of logical operation        256
//'       Stop           Stopping of logical operation        512
//'       Suspend        Suspension of logical operation      1024
//'       Resume         Resumption of logical operation      2048
//'       Transfer       Changing of correlation identity     4096
//'
//' TO DECIDE:
//'   I don't think we need the methods that don't pass a applicationCategory.  I also think we might want to skip the Info, Debug, and Trace
//'   versions that take a stacktrace flag.
//'   That would leave two versions for Failure and Error and one each for Warning, Info, Debug, and Trace.
//'
//' NOTES:
//'   The methods use the
//'           <System.Diagnostics.DebuggerStepThrough()> _
//'   attribute to suppress tracing through the logging code.  You can still set breakpoints in the method if you want.
//'
//'------------------------------------------------------------------------------------------------------------------------

//''' <summary>
//''' 
//''' </summary>
//''' <remarks>
//      Wrapper around EnterpriseLibrary.Logging.Logger.Write  
//      Simplifies calling by setting values for Priority and Severity.  
//      Passes several extended properties.
//  </remarks>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Reflection;

using Microsoft.Practices.EnterpriseLibrary.Common.Configuration;
using Microsoft.Practices.EnterpriseLibrary.Logging;

namespace VNC
{
    [Serializable]
    public partial class Log
    {
        private const long NoElapsedTime = 0L;

        static Log()
        {
            // NOTE(crhodes)
            // After a lot of work this returns the appropriate configuration for the calling assembly.
            // This allows us to have different logging configurations for different assemblies if we want.
            // It also allows us to have a default configuration that will be used if the calling assembly
            // doesn't have a configuration section defined.
            // In testing it takes less than a 0.2 microseconds to do this.  
            // So it is not a problem to do this in the static constructor and have it ready to go for the first log message.

            Int64 startTicks = Stopwatch.GetTimestamp();

            // NOTE(crhodes)
            // Above NOTE came from the Enterprise Library Logging Application Block documentation and code.
            // and was auto generated

            IConfigurationSource configurationSource = ConfigurationSourceFactory.Create();

            // NOTE(crhodes)
            // This returns a factory that contains "loggingConfiguration".
            // Don't think anything of real interest has happened yet. Magic must be in logWriterFactory.Create()

            LogWriterFactory logWriterFactory = new LogWriterFactory(configurationSource);

            // NOTE(crhodes)
            // Magic happens here. logWriterFactory.Create reads loggingConfiguration
            // and gets all the filters, formatters, and traceListeners
            // and sets the Logger Writer

            Logger.SetLogWriter(logWriterFactory.Create());

            Int64 frequency = Stopwatch.Frequency;
            // 10,000,000 ticks per second, so this is 100 nanoseconds per tick.  So this is 0.1 microseconds.

            Double duration = GetDuration(startTicks);
        }

        #region Public Write Methods

        [DebuggerStepThrough]
        public static void Write(Exception ex, TraceEventType severity, string category, LoggingPriority priority, 
                                 string className, string methodName, bool showStack)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category.Length == 0)
            {
                category = "General";
            }
            InternalWrite(ex.Message + ex.StackTrace, severity, category, priority, className, methodName, name, showStack);
        }

        [DebuggerStepThrough]
        public static void Write(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                 string className, string methodName, bool showStack)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category.Length == 0)
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, name, showStack);
        }

        [DebuggerStepThrough]
        public static void Write(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                 string className, string methodName, bool showStack, long startTicks)
        {
            string name = Assembly.GetCallingAssembly().GetName().Name;
            if (category.Length == 0)
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, name, showStack, startTicks);
        }

        [DebuggerStepThrough]
        public static void WriteLight(string message, TraceEventType severity, string category, LoggingPriority priority,
                                      string className, string methodName, bool showStack, long startTicks)
        {
            if (category.Length == 0)
            {
                category = "General";
            }
            InternalWrite(message, severity, category, priority, className, methodName, "<unknown>", showStack, startTicks);
        }

        #endregion

        #region Private Write Methods

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          int EventId)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          Dictionary<string, string> extendedProp)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);

            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }

            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          int EventId, Dictionary<string, string> extendedProp)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);

            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }

            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          long startTicks)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack,
                                          int EventId, long startTicks)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));
            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          Dictionary<string, string> extendedProp, long startTicks)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));

            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }

            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

        [DebuggerStepThrough]
        private static void InternalWrite(string message, TraceEventType severity, string category, LoggingPriority priority, 
                                          string className, string methodName, string callingAssemblyName, bool showStack, 
                                          int EventId, Dictionary<string, string> extendedProp, long startTicks)
        {
            string str = "";

            if (showStack)
            {
                StackTrace trace = new StackTrace();
                string str2 = "";
                foreach (StackFrame frame in trace.GetFrames())
                {
                    MethodBase method = frame.GetMethod();
                    str2 = method.ReflectedType.Name + "." + method.Name + " > " + str2;
                }
                str = str2 + " " + str;
            }

            LogEntry log = new LogEntry();

            if (category.Length == 0)
            {
                category = "General";
            }

            log.Categories.Add(category);
            log.EventId = EventId;
            log.Severity = severity;
            log.Priority = (int)priority;
            log.ExtendedProperties.Add("Calling Assembly", callingAssemblyName);
            log.ExtendedProperties.Add("Class Name", className);
            log.ExtendedProperties.Add("Method Name", methodName);
            log.ExtendedProperties.Add("Stack", str);
            log.ExtendedProperties.Add("User Name", Environment.UserName);
            log.ExtendedProperties.Add("Duration", GetDuration(startTicks));

            foreach (KeyValuePair<string, string> pair in extendedProp)
            {
                log.ExtendedProperties.Add(pair.Key, pair.Value);
            }

            log.Message = message;

            try
            {
                Logger.Write(log);
            }
			//catch (ServiceLocation.ActivationException)
			//{
			////	InternalWriter().Write(log);
			//}
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine(ex);
                throw ex;
            }
        }

		// This is new in EASE
		// Think it might be an alternative to the Log() constructor

		//private static LogWriter InternalWriter()
        //{
		//	//Internal Writer allows callers to just log without any configuration from the calling assembly
		//	//This also allows us to wrap tests around this class.
		//
        //    string loggingConfigSetting = Properties.Resources.LoggingConfiguration;
		//
        //    string tempConfigPath = System.IO.Path.GetTempFileName();
        //    System.IO.File.AppendAllText(tempConfigPath, loggingConfigSetting);
		//
        //    Microsoft.Practices.EnterpriseLibrary.Common.Configuration.FileConfigurationSource configSource = new Microsoft.Practices.EnterpriseLibrary.Common.Configuration.FileConfigurationSource(tempConfigPath);
        //    LogWriterFactory logFactory = new LogWriterFactory(configSource);
        //    return logFactory.Create();
        //}

    #endregion

<#
string[] named_methods = {
	"Failure",
	"Error",
	"Warning",
	};

foreach (string methodName in named_methods)
{
    string traceEventType = methodName;
    if (methodName == "Failure")
    {
        traceEventType = "Critical";
    }
#>
        #region Log <#= methodName #> Methods

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(Exception ex, string applicationCategory)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>, method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(Exception ex, string applicationCategory, 
                                            Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, 
                props);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(Exception ex, string applicationCategory, 
                                            int EventId)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, 
                EventId);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory, bool showStack)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory, 
                                            int EventId)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, 
                EventId);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory, 
                                            Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, 
                props);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(Exception ex, string applicationCategory, 
                                            int EventId, Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(ex.Message + ex.StackTrace, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, true, 
                EventId, props);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory, bool showStack, 
                                            Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, showStack, 
                props);
        }

        [DebuggerStepThrough]
        public static void <#= methodName.ToUpper() #>(string message, string applicationCategory, 
        int EventId, Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.<#= traceEventType #>, applicationCategory, LoggingPriority.<#= methodName #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, 
                EventId, props);
        }

    #endregion

<#
	}
#>
<#
string[] named_methods2 = {
	"INFO",
	"DEBUG",
	"ARCH",
	"TRACE"
	};

foreach (string methodName in named_methods2)
{		
#>
        #region Log <#= methodName #> Methods

<#
string level = "";
int levels = 0;

switch (methodName)
{
    case "INFO":
        levels = infoLevels;
        break;
    case "DEBUG":
        levels = debugLevels;
        break;
    case "ARCH":
        levels = archLevels;
        break;
    case "TRACE":
        levels = traceLevels;
        break;
}

for (int i = 0 ; i < levels ; i++)
{
	if (i > 0) level = i.ToString();
#>
        #region <#= methodName #><#= level #>

        // This is a light weight call
        // MethodInfo is not used, so we use "<unknown>" for class, method, and callingAssembly names.

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>Light(string message, string applicationCategory)
        {
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                "<unknown>", "<unknown>", "<unknown>", false); 
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            MethodBase method = null)
        {
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            int EventId)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, EventId);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            long startTicks, MethodBase method = null)
        {
            if (method == null) method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            int EventId, long startTicks)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, EventId, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            int EventId, Dictionary<string, string> props)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, EventId, props);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            Dictionary<string, string> props, long startTicks)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, props, startTicks);
            return Stopwatch.GetTimestamp();
        }

        [DebuggerStepThrough]
        public static long <#= methodName #><#= level #>(string message, string applicationCategory, 
                                            int EventId, Dictionary<string, string> props, long startTicks)
        {
            MethodBase method = new StackFrame(1).GetMethod();
            InternalWrite(message, TraceEventType.Information, applicationCategory, LoggingPriority.<#= methodName #><#= level #>,
                method.ReflectedType.Name, method.Name, Assembly.GetCallingAssembly().GetName().Name, false, EventId, props, startTicks);
            return Stopwatch.GetTimestamp();
        }

	    #endregion

<#
	}
#>
	    #endregion

<#
	}
#>
        public static double GetDuration(long startTicks)
        {
            return (double)(Stopwatch.GetTimestamp() - startTicks) / ((double)Stopwatch.Frequency);
        }

        public static double GetDuration(long startTicks, long endTicks)
        {
            return (double)(endTicks - startTicks) / ((double)Stopwatch.Frequency);
        }
    }
}